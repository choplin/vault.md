// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: version.sql

package sqldb

import (
	"context"
	"database/sql"
)

const CountVersionsByEntry = `-- name: CountVersionsByEntry :one
SELECT COUNT(*) AS count
FROM versions
WHERE entry_id = ?
`

func (q *Queries) CountVersionsByEntry(ctx context.Context, entryID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountVersionsByEntry, entryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteVersionByEntryAndVersion = `-- name: DeleteVersionByEntryAndVersion :execrows
DELETE FROM versions
WHERE entry_id = ? AND version = ?
`

type DeleteVersionByEntryAndVersionParams struct {
	EntryID int64 `json:"entry_id"`
	Version int64 `json:"version"`
}

func (q *Queries) DeleteVersionByEntryAndVersion(ctx context.Context, arg DeleteVersionByEntryAndVersionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, DeleteVersionByEntryAndVersion, arg.EntryID, arg.Version)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const DeleteVersionByID = `-- name: DeleteVersionByID :execrows
DELETE FROM versions
WHERE id = ?
`

func (q *Queries) DeleteVersionByID(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, DeleteVersionByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const DeleteVersionsByEntry = `-- name: DeleteVersionsByEntry :execrows
DELETE FROM versions
WHERE entry_id = ?
`

func (q *Queries) DeleteVersionsByEntry(ctx context.Context, entryID int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, DeleteVersionsByEntry, entryID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const FindVersionByEntryAndVersion = `-- name: FindVersionByEntryAndVersion :one
SELECT id, entry_id, version, file_path, hash, description, created_at
FROM versions
WHERE entry_id = ? AND version = ?
LIMIT 1
`

type FindVersionByEntryAndVersionParams struct {
	EntryID int64 `json:"entry_id"`
	Version int64 `json:"version"`
}

func (q *Queries) FindVersionByEntryAndVersion(ctx context.Context, arg FindVersionByEntryAndVersionParams) (Version, error) {
	row := q.db.QueryRowContext(ctx, FindVersionByEntryAndVersion, arg.EntryID, arg.Version)
	var i Version
	err := row.Scan(
		&i.ID,
		&i.EntryID,
		&i.Version,
		&i.FilePath,
		&i.Hash,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const FindVersionByID = `-- name: FindVersionByID :one
SELECT id, entry_id, version, file_path, hash, description, created_at
FROM versions
WHERE id = ?
LIMIT 1
`

func (q *Queries) FindVersionByID(ctx context.Context, id int64) (Version, error) {
	row := q.db.QueryRowContext(ctx, FindVersionByID, id)
	var i Version
	err := row.Scan(
		&i.ID,
		&i.EntryID,
		&i.Version,
		&i.FilePath,
		&i.Hash,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const InsertVersion = `-- name: InsertVersion :execresult
INSERT INTO versions (entry_id, version, file_path, hash, description)
VALUES (?, ?, ?, ?, ?)
`

type InsertVersionParams struct {
	EntryID     int64          `json:"entry_id"`
	Version     int64          `json:"version"`
	FilePath    string         `json:"file_path"`
	Hash        string         `json:"hash"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) InsertVersion(ctx context.Context, arg InsertVersionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, InsertVersion,
		arg.EntryID,
		arg.Version,
		arg.FilePath,
		arg.Hash,
		arg.Description,
	)
}

const ListVersionsByEntry = `-- name: ListVersionsByEntry :many
SELECT id, entry_id, version, file_path, hash, description, created_at
FROM versions
WHERE entry_id = ?
ORDER BY version DESC
`

func (q *Queries) ListVersionsByEntry(ctx context.Context, entryID int64) ([]Version, error) {
	rows, err := q.db.QueryContext(ctx, ListVersionsByEntry, entryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Version
	for rows.Next() {
		var i Version
		if err := rows.Scan(
			&i.ID,
			&i.EntryID,
			&i.Version,
			&i.FilePath,
			&i.Hash,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MaxVersionForEntry = `-- name: MaxVersionForEntry :one
SELECT CAST(COALESCE(MAX(version), 0) AS INTEGER) AS max_version
FROM versions
WHERE entry_id = ?
`

func (q *Queries) MaxVersionForEntry(ctx context.Context, entryID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, MaxVersionForEntry, entryID)
	var max_version int64
	err := row.Scan(&max_version)
	return max_version, err
}
