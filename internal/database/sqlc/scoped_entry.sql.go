// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scoped_entry.sql

package sqldb

import (
	"context"
	"database/sql"
)

const CountVersionsForScope = `-- name: CountVersionsForScope :one
SELECT COUNT(v.id) AS version_count
FROM entries e
JOIN versions v ON e.id = v.entry_id
WHERE e.scope_id = ?
`

func (q *Queries) CountVersionsForScope(ctx context.Context, scopeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountVersionsForScope, scopeID)
	var version_count int64
	err := row.Scan(&version_count)
	return version_count, err
}

const GetScopedEntryByVersion = `-- name: GetScopedEntryByVersion :one
SELECT
    e.id AS entry_id,
    e.scope_id,
    e.key,
    e.created_at AS entry_created_at,
    es.is_archived,
    v.version,
    v.file_path,
    v.hash,
    v.description,
    v.created_at AS version_created_at
FROM entries e
JOIN entry_status es ON e.id = es.entry_id
JOIN versions v ON e.id = v.entry_id
WHERE e.scope_id = ? AND e.key = ? AND v.version = ?
LIMIT 1
`

type GetScopedEntryByVersionParams struct {
	ScopeID int64  `json:"scope_id"`
	Key     string `json:"key"`
	Version int64  `json:"version"`
}

type GetScopedEntryByVersionRow struct {
	EntryID          int64          `json:"entry_id"`
	ScopeID          int64          `json:"scope_id"`
	Key              string         `json:"key"`
	EntryCreatedAt   sql.NullTime   `json:"entry_created_at"`
	IsArchived       sql.NullInt64  `json:"is_archived"`
	Version          int64          `json:"version"`
	FilePath         string         `json:"file_path"`
	Hash             string         `json:"hash"`
	Description      sql.NullString `json:"description"`
	VersionCreatedAt sql.NullTime   `json:"version_created_at"`
}

func (q *Queries) GetScopedEntryByVersion(ctx context.Context, arg GetScopedEntryByVersionParams) (GetScopedEntryByVersionRow, error) {
	row := q.db.QueryRowContext(ctx, GetScopedEntryByVersion, arg.ScopeID, arg.Key, arg.Version)
	var i GetScopedEntryByVersionRow
	err := row.Scan(
		&i.EntryID,
		&i.ScopeID,
		&i.Key,
		&i.EntryCreatedAt,
		&i.IsArchived,
		&i.Version,
		&i.FilePath,
		&i.Hash,
		&i.Description,
		&i.VersionCreatedAt,
	)
	return i, err
}

const GetScopedEntryLatest = `-- name: GetScopedEntryLatest :one
SELECT
    e.id AS entry_id,
    e.scope_id,
    e.key,
    e.created_at AS entry_created_at,
    es.is_archived,
    es.current_version,
    v.version,
    v.file_path,
    v.hash,
    v.description,
    v.created_at AS version_created_at
FROM entries e
JOIN entry_status es ON e.id = es.entry_id
JOIN versions v ON e.id = v.entry_id AND v.version = es.current_version
WHERE e.scope_id = ? AND e.key = ?
LIMIT 1
`

type GetScopedEntryLatestParams struct {
	ScopeID int64  `json:"scope_id"`
	Key     string `json:"key"`
}

type GetScopedEntryLatestRow struct {
	EntryID          int64          `json:"entry_id"`
	ScopeID          int64          `json:"scope_id"`
	Key              string         `json:"key"`
	EntryCreatedAt   sql.NullTime   `json:"entry_created_at"`
	IsArchived       sql.NullInt64  `json:"is_archived"`
	CurrentVersion   sql.NullInt64  `json:"current_version"`
	Version          int64          `json:"version"`
	FilePath         string         `json:"file_path"`
	Hash             string         `json:"hash"`
	Description      sql.NullString `json:"description"`
	VersionCreatedAt sql.NullTime   `json:"version_created_at"`
}

func (q *Queries) GetScopedEntryLatest(ctx context.Context, arg GetScopedEntryLatestParams) (GetScopedEntryLatestRow, error) {
	row := q.db.QueryRowContext(ctx, GetScopedEntryLatest, arg.ScopeID, arg.Key)
	var i GetScopedEntryLatestRow
	err := row.Scan(
		&i.EntryID,
		&i.ScopeID,
		&i.Key,
		&i.EntryCreatedAt,
		&i.IsArchived,
		&i.CurrentVersion,
		&i.Version,
		&i.FilePath,
		&i.Hash,
		&i.Description,
		&i.VersionCreatedAt,
	)
	return i, err
}

const ListEntriesWithVersionCount = `-- name: ListEntriesWithVersionCount :many
SELECT
    e.id AS entry_id,
    COUNT(v.id) AS version_count
FROM entries e
LEFT JOIN versions v ON e.id = v.entry_id
WHERE e.scope_id = ?
GROUP BY e.id
`

type ListEntriesWithVersionCountRow struct {
	EntryID      int64 `json:"entry_id"`
	VersionCount int64 `json:"version_count"`
}

func (q *Queries) ListEntriesWithVersionCount(ctx context.Context, scopeID int64) ([]ListEntriesWithVersionCountRow, error) {
	rows, err := q.db.QueryContext(ctx, ListEntriesWithVersionCount, scopeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntriesWithVersionCountRow
	for rows.Next() {
		var i ListEntriesWithVersionCountRow
		if err := rows.Scan(&i.EntryID, &i.VersionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListScopedEntriesAllVersions = `-- name: ListScopedEntriesAllVersions :many
SELECT
    e.id AS entry_id,
    e.scope_id,
    e.key,
    e.created_at AS entry_created_at,
    es.is_archived,
    v.version,
    v.file_path,
    v.hash,
    v.description,
    v.created_at AS version_created_at
FROM entries e
JOIN entry_status es ON e.id = es.entry_id
JOIN versions v ON e.id = v.entry_id
WHERE e.scope_id = ?
  AND (?2 OR es.is_archived = 0)
ORDER BY e.key, v.version DESC
`

type ListScopedEntriesAllVersionsParams struct {
	ScopeID         int64       `json:"scope_id"`
	IncludeArchived interface{} `json:"include_archived"`
}

type ListScopedEntriesAllVersionsRow struct {
	EntryID          int64          `json:"entry_id"`
	ScopeID          int64          `json:"scope_id"`
	Key              string         `json:"key"`
	EntryCreatedAt   sql.NullTime   `json:"entry_created_at"`
	IsArchived       sql.NullInt64  `json:"is_archived"`
	Version          int64          `json:"version"`
	FilePath         string         `json:"file_path"`
	Hash             string         `json:"hash"`
	Description      sql.NullString `json:"description"`
	VersionCreatedAt sql.NullTime   `json:"version_created_at"`
}

func (q *Queries) ListScopedEntriesAllVersions(ctx context.Context, arg ListScopedEntriesAllVersionsParams) ([]ListScopedEntriesAllVersionsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListScopedEntriesAllVersions, arg.ScopeID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScopedEntriesAllVersionsRow
	for rows.Next() {
		var i ListScopedEntriesAllVersionsRow
		if err := rows.Scan(
			&i.EntryID,
			&i.ScopeID,
			&i.Key,
			&i.EntryCreatedAt,
			&i.IsArchived,
			&i.Version,
			&i.FilePath,
			&i.Hash,
			&i.Description,
			&i.VersionCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListScopedEntriesLatest = `-- name: ListScopedEntriesLatest :many
SELECT
    e.id AS entry_id,
    e.scope_id,
    e.key,
    e.created_at AS entry_created_at,
    es.is_archived,
    es.current_version,
    v.version,
    v.file_path,
    v.hash,
    v.description,
    v.created_at AS version_created_at
FROM entries e
JOIN entry_status es ON e.id = es.entry_id
JOIN versions v ON e.id = v.entry_id AND v.version = es.current_version
WHERE e.scope_id = ?
  AND (?2 OR es.is_archived = 0)
ORDER BY e.key
`

type ListScopedEntriesLatestParams struct {
	ScopeID         int64       `json:"scope_id"`
	IncludeArchived interface{} `json:"include_archived"`
}

type ListScopedEntriesLatestRow struct {
	EntryID          int64          `json:"entry_id"`
	ScopeID          int64          `json:"scope_id"`
	Key              string         `json:"key"`
	EntryCreatedAt   sql.NullTime   `json:"entry_created_at"`
	IsArchived       sql.NullInt64  `json:"is_archived"`
	CurrentVersion   sql.NullInt64  `json:"current_version"`
	Version          int64          `json:"version"`
	FilePath         string         `json:"file_path"`
	Hash             string         `json:"hash"`
	Description      sql.NullString `json:"description"`
	VersionCreatedAt sql.NullTime   `json:"version_created_at"`
}

func (q *Queries) ListScopedEntriesLatest(ctx context.Context, arg ListScopedEntriesLatestParams) ([]ListScopedEntriesLatestRow, error) {
	rows, err := q.db.QueryContext(ctx, ListScopedEntriesLatest, arg.ScopeID, arg.IncludeArchived)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScopedEntriesLatestRow
	for rows.Next() {
		var i ListScopedEntriesLatestRow
		if err := rows.Scan(
			&i.EntryID,
			&i.ScopeID,
			&i.Key,
			&i.EntryCreatedAt,
			&i.IsArchived,
			&i.CurrentVersion,
			&i.Version,
			&i.FilePath,
			&i.Hash,
			&i.Description,
			&i.VersionCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListScopesWithCounts = `-- name: ListScopesWithCounts :many
SELECT
    s.id AS scope_id,
    COUNT(DISTINCT e.id) AS entry_count,
    COUNT(v.id) AS version_count
FROM scopes s
LEFT JOIN entries e ON s.id = e.scope_id
LEFT JOIN versions v ON e.id = v.entry_id
WHERE s.primary_path = ?
GROUP BY s.id
`

type ListScopesWithCountsRow struct {
	ScopeID      int64 `json:"scope_id"`
	EntryCount   int64 `json:"entry_count"`
	VersionCount int64 `json:"version_count"`
}

func (q *Queries) ListScopesWithCounts(ctx context.Context, primaryPath sql.NullString) ([]ListScopesWithCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListScopesWithCounts, primaryPath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScopesWithCountsRow
	for rows.Next() {
		var i ListScopesWithCountsRow
		if err := rows.Scan(&i.ScopeID, &i.EntryCount, &i.VersionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
